class MerchantHandler : HDCoreEventHandler {

	private int MoneyMode;
	private bool SpawnedTiberium;

	Array<HDMerchantSkin> Skins;
	Array<name> NonBountyBlacklist;

	override void beforeProcessCommands() {
		BountyTargets.clear();
		NonBountyBlacklist.clear();
		SafeMapNames.clear();
		Skins.clear();
		StoreCurrencies.clear();
		StoreItems.clear();
		
		initBounties();
		initCurrencies();
		initStores();
	}

	override void processCommand(HDCoreCommand cmd) {
		switch (cmd.command) {
			case 'newMerchantBountyTarget': {

				// Get Target's ClassName and check if it's valid
				let name = cmd.getNameParam("name");
				Class<Actor> cls = name;

				// If the target's class doesn't exist, quit.
				if (!cls) break;

				// get remaining params
				let effect = cmd.getNameParam("effect");
				let value = cmd.getIntParam("value");

				// Look for existing bounty target definitions
				BountyTarget existingTarget;
				forEach (t : BountyTargets) {
					if (t.targetCls == name) {
						existingTarget = t;
						break;
					}
				}

				// If an existing target for this class already exists, quit.
				if (existingTarget) break;

				// Create the new Bounty Target and add it to the registry.
				let newTarget = BountyTarget.create(name, value, effect);

				if (newTarget) BountyTargets.push(newTarget);

				break;
			}
			case 'removeMerchantBountyTarget': {

				let name = cmd.getNameParam("name");

				forEach (target : BountyTargets) {
					if (target.targetCls == name) {
						BountyTargets.delete(BountyTargets.find(target));
						break;
					}
				}

				break;
			}
			case 'clearMerchantBountyTargets': {
				BountyTargets.clear();
				break;
			}
			case 'addMerchantNonBountyBlacklist': {
				
				let name = cmd.getNameParam("name");

				if (name && NonBountyBlacklist.find(name) == NonBountyBlacklist.size()) NonBountyBlacklist.push(name);

				break;
			}
			case 'removeMerchantNonBountyBlacklist': {

				let name = cmd.getNameParam("name");

				if (NonBountyBlacklist.find(name) < NonBountyBlacklist.size()) NonBountyBlacklist.delete(NonBountyBlacklist.find(name));

				break;
			}
			case 'clearMerchantNonBountyBlacklist': {
				NonBountyBlacklist.clear();
				break;
			}
			case 'addMerchantSafeMap': {
				let name = cmd.getNameParam("name");

				if (name && SafeMapNames.find(name) == SafeMapNames.size()) SafeMapNames.push(name);
				break;
			}
			case 'removeMerchantSafeMap': {
				let name = cmd.getNameParam("name");

				if (SafeMapNames.find(name) < SafeMapNames.size()) SafeMapNames.delete(SafeMapNames.find(name));

				break;
			}
			case 'clearMerchantSafeMaps': {
				SafeMapNames.clear();
				break;
			}
			case 'newMerchantSkin': {

				// Get Skin ID
				let id = cmd.getNameParam("name");

				// Get remaining params
				let tag = cmd.getStringParam("tag", "$TAG_MERCHANT");
				let sprite = cmd.getNameParam("sprite", 'HOBM');
				let scaleX = cmd.getDoubleParam("scaleX", 1.0);
				let scaleY = cmd.getDoubleParam("scaleY", 1.0);
				let openState = cmd.getNameParam("openState", 'OpenMenu.Default');
				let closeState = cmd.getNameParam("closeState", 'SpawnLoop');
				let openSound = cmd.getNameParam("openSound");
				let closeSound = cmd.getNameParam("closeSound");

				vector2 scale = (scaleX, scaleY);

				HDMerchantSkin existingSkin;
				forEach (skin : Skins) {
					let currId = skin.skinId;

					if (currId != '' && id != '' && currId == id) {
						existingSkin = skin;
						break;
					}
				}

				if (existingSkin) break;

				let newskin = HDMerchantSkin.create(id, tag, sprite, scale, openState, openSound, closeState, closeSound);

				if (newSkin) skins.push(newSkin);

				break;
			}
			case 'removeMerchantSkin': {

				let name = cmd.getNameParam("name");

				forEach (skin : Skins) {
					if (skin.skinId == name) {
						Skins.delete(Skins.find(skin));
						break;
					}
				}

				break;
			}
			case 'clearMerchantSkins': {
				Skins.clear();
				break;
			}
			case 'newMerchantStore': {
				
				// Get Store Type
				let type = cmd.getNameParam("type");

				// get remaining params
				let chance = cmd.getDoubleParam("chance", -1.0);
				let skinsParam = cmd.getStringParam("skins", "");
				let stockMult = cmd.getDoubleParam("stockMult", 1.0);
				let priceMult = cmd.getDoubleParam("priceMult", 1.0);

				// Look for existing store definitions
				MerchantStore existingStore;
				forEach (store : Stores) {
					let currType = store.type;

					if (currType != '' && type != '' && currType == type) {
						existingStore = store;
						break;
					}
				}

				// If an existing store for this type already exists, quit.
				if (existingStore) break;

				// Create the new store and add it to the registry.
				let newStore = MerchantStore.create(
					type,
					chance,
					stockMult,
					priceMult
				);

				HDCore.log('Merchant', LOGGING_DEBUG, type.." => "..skinsParam);

				// Parse out Skins Param
				if (skinsParam != "") {

					Array<string> skinsArr;
					skinsArr.clear();

					let skinsFlags = skinsParam.toInt(10);
					if (skinsFlags > 0) {

						// Store the default Skin IDs
						name defaultSkins[10] = {
							'ResidentEvil',
							'Hobo',
							'Succubus',
							'Morshu',
							'WanderingTrader',
							'Daina1',
							'Daina2',
							'Daina3',
							'Daina4',
							'Nari1'
						};

						// If we've selected any skins for this store type, add them.
						for (let i = 0; i < defaultSkins.size(); i++) if (skinsFlags & 1 << i) skinsArr.push(defaultSkins[i]);

					} else {
						skinsParam.split(skinsArr, ",", TOK_SKIPEMPTY);
					}

					forEach(skin : skinsArr) {
						skin.stripLeftRight();
						newStore.addSkin(skin);
					}
				}

				if (newStore) stores.push(newStore);

				break;
			}
			case 'removeMerchantStore': {

				let type = cmd.getNameParam("type");

				forEach (store : Stores) {
					if (store.type == type) {
						Stores.delete(Stores.find(store));
						break;
					}
				}

				break;
			}
			case 'clearMerchantStores': {
				Stores.clear();
				break;
			}
			case 'newMerchantStoreCurrency': {
				
				// Get Currency name and check if it's valid
				let currency = cmd.getNameParam("name");
				Class<Inventory> currencyCls = currency;

				// If the currency's class doesn't exist, quit.
				if (!currencyCls) break;

				// get remaining params
				let icon = cmd.getStringParam("icon");
				let priceMult = cmd.getDoubleParam("priceMult", 1.0);

				// Look for existing currency definitions
				StoreCurrency existingCurrency;
				forEach (c : StoreCurrencies) {
					let currName = c.getCurrencyClass();

					if (currName != '' && currency != '' && currName == currency) {
						existingCurrency = c;
						break;
					}
				}

				// If an existing currency for this class already exists, quit.
				if (existingCurrency) break;

				// Create the new currency and add it to the registry.
				let newCurrency = StoreCurrency.create(currency, icon, priceMult);

				if (newCurrency) {
					if (cmd.getBoolParam("default")) {
						StoreCurrencies.insert(0, newCurrency);
					} else {
						StoreCurrencies.push(newCurrency);
					}
				}

				break;
			}
			case 'removeMerchantStoreCurrency': {
				let currency = cmd.getNameParam("name");

				forEach (storeCurrency : StoreCurrencies) {
					if (storeCurrency.cls == currency) {
						StoreCurrencies.delete(StoreCurrencies.find(storeCurrency));
						break;
					}
				}

				break;
			}
			case 'clearMerchantStoreCurrencies': {
				StoreCurrencies.clear();
				break;
			}
			case 'newMerchantStoreItem': {
				
				// Get Item name and check if it's valid
				let item = cmd.getNameParam("item");
				Class<Actor> itemCls = item;
				
				// If the item's class doesn't exist, quit.
				if (!itemCls) break;
				
				// Get Item type and check if it's valid
				let type = cmd.getNameParam("type");

				// get remaining params
				let chance = cmd.getDoubleParam("chance", -1.0);
				let category = cmd.getStringParam("category", type);
				let icon = cmd.getStringParam("icon");
				let displayName = cmd.getStringParam("displayName", item);
				let flavorText = cmd.getStringParam("flavorText");
				let baseAmount = cmd.getIntParam("amount", 1);
				let basePrice = cmd.getIntParam("basePrice", 1);
				let baseStoreAmount = cmd.getIntParam("storeAmount");

				StoreItem existingItem;
				forEach (i : StoreItems) {
					let itemName = i.getItem();

					if (itemName != '' && item != '' && itemName == item) {
						existingItem = i;
						break;
					}
				}

				// If an existing store item for this class already exists, quit.
				if (existingItem) break;

				// Create the new store item and add it to the registry.
				let newItem = StoreItem.create(
					type,
					chance,
					category,
					item,
					icon,
					displayName,
					flavorText,
					baseAmount,
					basePrice,
					baseStoreAmount
				);

				if (newItem) StoreItems.push(newitem);

				break;
			}
			case 'removeMerchantStoreItem': {
				let item = cmd.getNameParam("name");

				forEach (storeItem : StoreItems) {
					if (storeItem.getItem() == item) {
						StoreItems.delete(StoreItems.find(storeItem));
						break;
					}
				}

				break;
			}
			case 'clearMerchantStoreItems': {
				StoreItems.clear();
				break;
			}
			default: {
				break;
			}
		}
	}

	override void afterProcessCommands() {
		if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) {

			let msg = "Merchant Bounty Targets:\n";
			
			forEach (target : BountyTargets) msg = msg.." * "..target.toString().."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);


			msg = "Merchant Safe Maps:\n";

			forEach (mapName : SafeMapNames) msg = msg.." * "..mapName.."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);


			msg = "Merchant Skins:\n";

			forEach (skin : Skins) msg = msg.." * "..skin.toString().."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);


			msg = "Merchant Currencies:\n";
			forEach (currency : StoreCurrencies) msg = msg.." * "..currency.toString().."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);


			msg = "Merchant Stores:\n";

			forEach (store : Stores) msg = msg.." * "..store.toString().."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);


			msg = "Merchant Store Items:\n";

			forEach (item : StoreItems) msg = msg.." * "..item.toString().."\n";

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);
		}
	}

	HDMerchantSkin getMerchantSkin(name skinId) {
		forEach(skin : Skins) if (skin.skinId == skinId) return skin;

		return null;
	}

	override void NetworkProcess(ConsoleEvent e) {

		let plr = players[e.Player].mo;
		name eventName = e.name;

		switch (eventName) {
			case 'HDM_AssemblePokerGame': {
				AssembleGame(plr);

				break;
			}
			case 'HDMPlaceBet': {
				PlaceBet(CardPlayers[PlayerIndex], e.Args[0]);

				break;
			}
			case 'HDM_Fold': {
				ActionTimer = 0;

				CardPlayers[PlayerIndex].HasFolded = true;
				RotatePlayer();

				break;
			}
			case 'HDM_Check': {
				ActionTimer = 0;

				CardPlayers[PlayerIndex].HasChecked = true;
				CardPlayers[PlayerIndex].Player.A_StartSound("Poker/Check", 10, CHANF_UI, attenuation: 1.5);
				RotatePlayer();

				break;
			}
			default: {
				Array<string> ParsedName;
				e.name.Split(ParsedName, ":");

				if (ParsedName[0] ~== "HDM_BuyStuff") {

					forEach (store : Stores) {

						StoreItem item;
						forEach (storeItem : store.StoreItems) {

							if (storeItem.GetItem() == ParsedName[1]) {
								item = storeItem;
								break;
							}
						}
		
						if (item && plr) {

							class<Actor> ItemClass = item.GetItem();
							int Amount = item.GetAmount();
		
							StoreCurrency Currency = StoreCurrencies[e.Args[0]];
							int Price = StoreItem.GetAdjustedPrice(item, Currency);
		
							// If the price is too high, play failure sound and quit.
							if (Price > plr.CountInv(Currency.GetCurrencyClass())) {
								plr.A_StartSound("Merchant/BuyFailure", 15, CHANF_LOCAL | CHANF_UI);
								return;
							}

							// If the thing bought is a pickup or pickup giver, give to the player & dump the overflow
							// otherwise just dump the thing on the ground.
							if (!(ItemClass is 'HDPickup') || ItemClass is 'HDPickupGiver') {
								Actor a; bool success;

								[success, a] = plr.A_SpawnItemEx(
									ItemClass,
									6, 0, plr.height - 8,
									frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0),
									0,
									SXF_NOCHECKPOSITION
								);

								if (success && a is 'Inventory') Inventory(a).Amount = amount;
							} else {
								class<Inventory> InvClass = (class<Inventory>)(ItemClass);
								int MaxGive = GetDefaultByType(InvClass).MaxAmount - plr.CountInv(InvClass);
								int MaxActualGive = min(Amount, MaxGive);

								// [Ace] Give what you can directly and drop the rest on the ground.
								plr.A_GiveInventory(InvClass, MaxActualGive);
								Amount -= MaxActualGive;

								if (Amount > 0) {
									Actor a; bool success;

									[success, a] = plr.A_SpawnItemEx(
										InvClass,
										6, 0, plr.height - 8,
										frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0),
										0,
										SXF_NOCHECKPOSITION
									);

									if (success) Inventory(a).Amount = Amount;
								}
							}

							// Take the currency from the player, play success sound, reduce stock
							plr.A_TakeInventory(Currency.GetCurrencyClass(), Price);
							plr.A_StartSound("Merchant/BuySuccess", 16, CHANF_LOCAL | CHANF_UI);
							item.StoreAmount--;

							// If there's none left, remove from the store.
							// TODO: Mark as disabled instead?
							if (item.StoreAmount <= 0) {
								store.StoreItems.Delete(store.StoreItems.Find(item));
								item.Destroy();
							}

							break;
						}
					}
				}

				break;
			}
		}
	}

	override void WorldLoaded(WorldEvent e) {

		super.worldLoaded(e);

		if (e.IsReopen) return;

		MoneyMode = hdm_moneymode == 3 ? random(0, 1) : hdm_moneymode;
		
		// Initialize the stores for this map
		for (int i = 0; i < Stores.Size(); ++i) InitStore(Stores[i].type);
		
		if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) {
			let msg = "Merchant Stores:\n";

			forEach (store : Stores) {
				forEach (category : store.Categories) {
					msg = msg.." * "..category.." Items:\n";

					forEach (item : store.StoreItems) {
						if (item.GetCategory() == category) {
							msg = msg.."   * "..item.toString().."\n";
						}
					}
				}
			}

			HDCore.Log('Merchant', LOGGING_DEBUG, msg);
		}

		Array<MerchantStore> AvailableStores;
		AvailableStores.copy(Stores);

		int mCount = Stores.Size();
		int MerchantsLeft = min(mCount, level.MapName ~== "LOTSAGUN" ? mCount : CVar.GetCVar('hdm_maxmerchants').GetInt());

		Array<Sector> dedicatedMerchantSectors;
		Array<Sector> dedicatedSlotSectors;
		Array<Sector> secretSectors;

		foreach (sec : level.sectors) {
			if (sec.GetUDMFInt('user_merchantsector') == 1) {
				dedicatedMerchantSectors.Push(sec);
				continue;
			}

			if (sec.GetUDMFInt('user_slotmachinesector') == 1) {
				dedicatedSlotSectors.Push(sec);
				continue;
			}

			// [Ace] Secret sectors that are already dedicated don't count.
			
			// NOTE I: Don't spawn stuff in low sectors to prevent softlocking. You can climb crystals, but not if you slam your head into the ceiling doing so.
			if (
				sec.IsSecret()
				&& dedicatedMerchantSectors.Find(sec) == dedicatedMerchantSectors.Size()
				&& dedicatedSlotSectors.Find(sec) == dedicatedSlotSectors.Size()
			) {
				Vector2 center = sec.centerspot;
				double secHeight = abs(sec.floorplane.ZAtPoint(center) - sec.ceilingplane.ZAtPoint(center));

				if (secHeight < 64) continue;

				secretSectors.Push(sec);
			}
		}

		int validSectorCount = secretSectors.Size();
		if (validSectorCount == 0 && dedicatedMerchantSectors.Size() == 0 && dedicatedSlotSectors.Size() == 0) return;

		// [Ace] Sort sectors by size in ascending order. Spawn merchants in smaller sectors first. Tiberium is the opposite - it prioritizes bigger sectors first.
		for (int i = 0; i < secretSectors.Size() - 1; ++i) {
			for (int j = i + 1; j < secretSectors.Size(); ++j) {
				if (AceCore.GetSectorSize(secretSectors[i]) > AceCore.GetSectorSize(secretSectors[j])) {
					let swap = secretSectors[i];
					secretSectors[i] = secretSectors[j];
					secretSectors[j] = swap;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// BITCHES DON'T KNOW 'BOUT MY TIBERIUM DEPOSITS.
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Spawn the crystals first, and only then bother with the merchants.
		if (MoneyMode == 0 || MoneyMode == 2) {

			for (int i = secretSectors.Size() - 1; i >= 0; --i) {
				if (hdm_debug || random[merchrand](1, 100) <= AceCore.GetscaledChance(5, 40, acl_spawnscale_min, acl_spawnscale_max)) {
					SpawnedTiberium = true;

					SpawnCrystals(secretSectors[i]);
					secretSectors.Delete(i);

					if (hdm_debug) break;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		//	MERCHANT SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Some boilerplate because I can't make local functions and the workaround is ironically worse.
		foreach (sec : dedicatedMerchantSectors) {
			Vector3 spawnPos = (sec.centerspot, sec.floorplane.ZAtPoint(sec.centerspot));
			int storeIndex = random(0, AvailableStores.Size() - 1);
			let a = HDMerchant(Actor.Spawn('HDMerchant', spawnPos));

			if (a) {
				a.storetype = Stores[storeIndex].type;
				a.angle = sec.GetUDMFInt('user_merchantangle');
				AvailableStores.Delete(storeIndex);
	
				if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) HDCore.Log(
					'Merchant', LOGGING_DEBUG, String.format(
						"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
						a.GetTag(), spawnPos.x, spawnPos.y
					)
				);
	
				if (--MerchantsLeft == 0) break;
			}
		}

		if (MerchantsLeft && AvailableStores.Size()) {
			for (int i = 0; i < secretSectors.Size(); ++i) {
				Vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 30) continue;
				int storeIndex = random(0, AvailableStores.Size() - 1);
				let a = HDMerchant(Actor.Spawn('HDMerchant', spawnPos));

				if (a) {
					a.StoreType = AvailableStores[storeIndex].type;
					a.angle = secretSectors[i].GetUDMFInt('user_merchantangle');
					AvailableStores.Delete(storeIndex);
					secretSectors.Delete(i--);

					if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) HDCore.Log(
						'Merchant', LOGGING_DEBUG, String.format(
							"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
							a.GetTag(), spawnPos.x, spawnPos.y
						)
					);
	
					if (--MerchantsLeft == 0) break;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// SLOT MACHINE SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		bool spawnedMachine = false;
		for (int i = 0; i < dedicatedSlotSectors.Size(); i++) {

			Vector3 spawnPos = (dedicatedSlotSectors[i].centerspot, dedicatedSlotSectors[i].floorplane.ZAtPoint(dedicatedSlotSectors[i].centerspot));

			Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
			a.angle = dedicatedSlotSectors[i].GetUDMFInt('user_slotmachineangle');
			spawnedMachine = true;

			if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) HDCore.Log(
				'Merchant', LOGGING_DEBUG, String.format(
					"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
					a.GetTag(), spawnPos.x, spawnPos.y
				)
			);
		}

		if (!spawnedMachine && hdm_enableslots) {

			for (int i = 0; i < secretSectors.Size(); i++) {

				Vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 20) continue;

				Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
				a.angle = secretSectors[i].GetUDMFInt('user_slotmachineangle');
				secretSectors.Delete(i--);

				if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) HDCore.Log(
					'Merchant', LOGGING_DEBUG, String.format(
						"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
						a.GetTag(), spawnPos.x, spawnPos.y
					)
				);

				break;
			}
		}
	}

	override void WorldUnloaded(WorldEvent e) {

		let plr = players[Net_Arbitrator].mo;
		if (!plr) return;

		forEach (p : PLAYERS) if (p.mo) p.mo.A_TakeInventory("HDMerchantBody");
	}

	override void WorldTick() {

		if (GameInProgress) PokerTick();

		// Initialize Bounty Target(s) Selection
		if (level.time == 35 && (MoneyMode == 1 || (MoneyMode == 2 && !SpawnedTiberium))) {
			int count = 1;
			for (int i = 0; i < 2; ++i) {

				if (random() <= AceCore.GetscaledChance(0, 64, 5, 15 + (5 * i))) {
					count++;
				} else {
					break;
				}
			}

			InitBountyTargets(count);
		}
	}

	override void WorldThingDied(WorldEvent e) {

		// If thing isn't some sort of HDMobBase, quit.
		// TODO: Expand to whitelist
		if (!(e.thing is 'HDMobBase')) return;

		// If thing is blacklisted, quit.
		forEach (bl : NonBountyBlacklist) if (e.thing is bl) return;

		// If the Non-Bounty Drop Ratio is a positive value,
		// and the thing hasn't died/dropped yet, drop currency.
		let mob = HDMobBase(e.thing);
		if (hdm_nonbounty_dropratio > 0 && !mob.bHASDROPPED) DropCurrency(mob);
	}

	private void DropCurrency(HDMobBase mob) {

		// Get the raw amount of currency to drop
		let bounty = GetBounty(mob);
		let healthamt = mob.getspawnhealth() + (mob.maxshields / 2);
		let maxAmount = random(min(bounty, healthamt), max(bounty, healthamt)) * hdm_nonbounty_dropratio;
		let amount = random(0, maxAmount);

		if (hdm_nonbounty_directdeposit) {

			// Genericfiredemon: Code taken from line 263 of Bounty.zsc and modified for basic cash.
			AceCore.GiveToPlayers('MercenaryBucks', amount);
		} else {

			while (amount > 0) {

				if (amount >= 2000) {
					mob.DropNewItem('BigGem');
					amount -= 2000;
				} else if (amount >= 1000) {
					mob.DropNewItem('SmallGem');
					amount -= 1000;
				} else if (amount >= 750) {
					mob.DropNewItem('BigCoin');
					amount -= 750;
				} else if (amount >= 500) {
					mob.DropNewItem('MediumCoin');
					amount -= 500;
				} else if (amount >= 250) {
					mob.DropNewItem('SmallCoin');
					amount -= 250;
				} else if (amount >= 100) {
					mob.DropNewItem('MercenaryBucks100');
					amount -= 100;
				} else if (amount >= 25) {
					mob.DropNewItem('MercenaryBucks25');
					amount -= 25;
				} else {
					mob.DropNewItem('MercenaryBucks1');
					amount -= 1;
				}
			}
		}
	}
}
