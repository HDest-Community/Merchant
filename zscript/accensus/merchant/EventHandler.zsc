class MerchantHandler : EventHandler
{
	private int MoneyMode;
	private bool SpawnedTiberium;

	bool initialized;

	// Populates the Merchant Store Lists.
	void init() {

		if (initialized) return;

		SafeMapNames.clear();
		StoreCurrencies.clear();
		StoreItems.clear();

		let cmdReader = HDCoreInfoReader(StaticEventHandler.find('HDCoreInfoReader'));
		
		// Process all HDCore Commands,
		// as well as all loaded Child Classes for Store Items/Currencies
		initCurrencies();
		initStores();
		loadMerchantLists(cmdReader.commands);

		if (hd_debug) {
			Console.printF("Merchant Safe Maps:");
			forEach(mapName : SafeMapNames) Console.printF(" * "..mapName);

			Console.printF("Merchant Currencies:");
			forEach(currency : StoreCurrencies) Console.printF(" * "..currency.toString());

			Console.printF("Merchant Store Items:");
			forEach(item : StoreItems) Console.printF(" * "..item.toString());
		}

		initialized = true;
	}

	void loadMerchantLists(Array<HDCoreCommand> cmds) {
		forEach (cmd : cmds) {
			switch (cmd.command) {
				case 'newMerchantSafeMap': {
					let name = cmd.getNameParam("name");

					if (name && safeMapNames.find(name) == safeMapNames.size()) safeMapNames.push(name);
					break;
				}
				case 'removeMerchantSafeMap': {
					let name = cmd.getNameParam("name");

					forEach (mapName : SafeMapNames) {
						if (mapName == name) {
							SafeMapNames.delete(SafeMapNames.find(mapName));
							break;
						}
					}

					break;
				}
				case 'clearMerchantSafeMaps': {
					SafeMapNames.clear();
					break;
				}
				case 'newMerchantStoreCurrency': {
					
					// Get Currency name and check if it's valid
					let currency = cmd.getNameParam("name");
					Class<Inventory> currencyCls = currency;

					// If the currency's class doesn't exist, quit.
					if (!currencyCls) break;

					// get remaining params
					let icon = cmd.getStringParam("icon");
					let priceMult = cmd.getDoubleParam("priceMult", 1.0);

					// Look for existing currency definitions
					StoreCurrency existingCurrency;
					forEach (c : StoreCurrencies) {
						if (c.cls == currency) {
							existingCurrency = c;
							break;
						}
					}

					// If an existing currency for this class already exists, quit.
					if (existingCurrency) break;

					// Create the new currency and add it to the registry.
					let newCurrency = StoreCurrency.create(currency, icon, priceMult);

					if (newCurrency) StoreCurrencies.push(newCurrency);

					break;
				}
				case 'removeMerchantStoreCurrency': {
					let currency = cmd.getNameParam("name");

					forEach (storeCurrency : StoreCurrencies) {
						if (storeCurrency.cls == currency) {
							StoreCurrencies.delete(StoreCurrencies.find(storeCurrency));
							break;
						}
					}

					break;
				}
				case 'clearMerchantStoreCurrencies': {
					StoreCurrencies.clear();
					break;
				}
				case 'newMerchantStoreItem': {
					
					// Get Item name and check if it's valid
					let item = cmd.getNameParam("item");
					Class<Actor> itemCls = item;
					
					// If the item's class doesn't exist, quit.
					if (!itemCls) break;
					
					// Get Item type and check if it's valid
					let type = cmd.getNameParam("type");
					int sType = -1;
					switch (type) {
						case 'ammo': {
							sType = SType_Ammo;
							break;
						}
						case 'item': {
							sType = SType_Item;
							break;
						}
						case 'weapon': {
							sType = SType_Weapon;
							break;
						}
						default: {
							Console.printF("\c[Red][MerchantHandler] Unknown Merchant Store Type: "..cmd.getNameParam("type"));
							break;
						}
					}
					
					// If the item type isn't valid, quit.
					if (sType < 0) break;

					// get remaining params
					let enabled = cmd.getBoolParam("enabled", true);
					let category = cmd.getStringParam("category", type);
					let icon = cmd.getStringParam("icon");
					let displayName = cmd.getStringParam("displayName", item);
					let flavorText = cmd.getStringParam("flavorText");
					let baseAmount = cmd.getIntParam("amount", 1);
					let basePrice = cmd.getIntParam("basePrice", 1);

					StoreItem existingItem;
					forEach (i : StoreItems) {
						if (i.getItem() == item) {
							existingItem = i;
							break;
						}
					}

					// If an existing store item for this class already exists, quit.
					if (existingItem) break;

					// Create the new store item and add it to the registry.
					let newItem = StoreItem.create(
						enabled,
						sType,
						category,
						item,
						icon,
						displayName,
						flavorText,
						baseAmount,
						basePrice
					);

					if (newItem) StoreItems.push(newitem);

					break;
				}
				case 'removeMerchantStoreItem': {
					let item = cmd.getNameParam("name");

					forEach (storeItem : StoreItems) {
						if (storeItem.getItem() == item) {
							StoreItems.delete(StoreItems.find(storeItem));
							break;
						}
					}

					break;
				}
				case 'clearMerchantStoreItems': {
					StoreItems.clear();
					break;
				}
				default: {
					break;
				}
			}
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = players[e.Player].mo;

		if (e.Name ~== "HDM_AssemblePokerGame")
		{
			AssembleGame(plr);
			return;
		}

		if (e.Name ~== "HDM_PlaceBet")
		{
			PlaceBet(CardPlayers[PlayerIndex], e.Args[0]);
			return;
		}

		if (e.Name ~== "HDM_Fold")
		{
			CardPlayers[PlayerIndex].HasFolded = true;
			ActionTimer = 0;
			RotatePlayer();
			return;
		}

		if (e.Name ~== "HDM_Check")
		{
			ActionTimer = 0;
			CardPlayers[PlayerIndex].HasChecked = true;
			CardPlayers[PlayerIndex].Player.A_StartSound("Poker/Check", 10, CHANF_UI, attenuation: 1.5);
			RotatePlayer();
			return;
		}

		Array<string> ParsedName;
		e.Name.Split(ParsedName, ":");
		if (ParsedName[0] ~== "HDM_BuyStuff")
		{
			for (int i = 0; i < Stores.Size(); ++i)
			{
				StoreItem item;
				for (int j = 0; j < Stores[i].StoreItems.Size(); ++j)
				{
					if (Stores[i].StoreItems[j].GetClass() == ParsedName[1])
					{
						item = Stores[i].StoreItems[j];
						break;
					}
				}

				if (item && plr)
				{
					class<Actor> ItemClass = item.GetItem();
					int Amount = item.GetAmount();

					StoreCurrency Currency = StoreCurrencies[e.Args[0]];
					int Price = StoreItem.GetAdjustedPrice(item, Currency);

					if (Price > plr.CountInv(Currency.GetCurrencyClass()))
					{
						plr.A_StartSound("Merchant/BuyFailure", 15, CHANF_LOCAL | CHANF_UI);
						return;
					}

					if (!(ItemClass is 'HDPickup') ||  ItemClass is 'HDPickupGiver')
					{
						Actor a; bool success;
						[success, a] = plr.A_SpawnItemEx(ItemClass, 6, 0, plr.height - 8, frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
						if (success && a is 'Inventory')
						{
							Inventory(a).Amount = amount;
						}
					}
					else
					{
						class<Inventory> InvClass = (class<Inventory>)(ItemClass);
						int MaxGive = GetDefaultByType(InvClass).MaxAmount - plr.CountInv(InvClass);
						int MaxActualGive = min(Amount, MaxGive);

						// [Ace] Give what you can directly and drop the rest on the ground.
						plr.A_GiveInventory(InvClass, MaxActualGive);
						Amount -= MaxActualGive;

						if (Amount > 0)
						{
							Actor a; bool success;
							[success, a] = plr.A_SpawnItemEx(InvClass, 6, 0, plr.height - 8, frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
							if (success)
							{
								Inventory(a).Amount = Amount;
							}
						}
					}
					plr.A_TakeInventory(Currency.GetCurrencyClass(), Price);
					plr.A_StartSound("Merchant/BuySuccess", 16, CHANF_LOCAL | CHANF_UI);

					item.StoreAmount--;
					if (item.StoreAmount == 0)
					{
						Stores[i].StoreItems.Delete(Stores[i].StoreItems.Find(item));
						item.Destroy();
					}
					break;
				}
			}
		}
	}

	override void WorldLoaded(WorldEvent e)
	{
		if (e.IsReopen) return;

        // Populates the main arrays if they haven't been already.
        if (!initialized) init();

		MoneyMode = hdm_moneymode == 3 ? random(0, 1) : hdm_moneymode;
		
		// Initialize the stores for this map
		for (int i = 0; i < Stores.Size(); ++i) InitStore(i);
		
		if (hd_debug) {
			Console.printF("Merchant Stores:");
			forEach(store : Stores) {
				forEach(category : store.Categories) {
					Console.printF(" * "..category.." Items:");
					forEach(item : store.StoreItems) {
						if (item.GetCategory() == category) {
							Console.printF("   * "..item.toString());
						}
					}
				}
			}
		}

		Array<class<HDMerchant> > AvailableMerchants;
		AvailableMerchants.Push((class<HDMerchant>)('AmmoMerchant'));
		AvailableMerchants.Push((class<HDMerchant>)('ItemMerchant'));
		AvailableMerchants.Push((class<HDMerchant>)('WeaponMerchant'));

		int mCount = AvailableMerchants.Size();
		int MerchantsLeft = min(mCount, level.MapName ~== "LOTSAGUN" ? mCount : CVar.GetCVar('hdm_maxmerchants').GetInt());

		Array<Sector> dedicatedMerchantSectors;
		Array<Sector> dedicatedSlotSectors;
		Array<Sector> secretSectors;

		foreach (sec : level.sectors) {
			if (sec.GetUDMFInt('user_merchantsector') == 1) {
				dedicatedMerchantSectors.Push(sec);
				continue;
			}

			if (sec.GetUDMFInt('user_slotmachinesector') == 1) {
				dedicatedSlotSectors.Push(sec);
				continue;
			}

			// [Ace] Secret sectors that are already dedicated don't count.
			
			// NOTE I: Don't spawn stuff in low sectors to prevent softlocking. You can climb crystals, but not if you slam your head into the ceiling doing so.
			if (
				sec.IsSecret()
				&& dedicatedMerchantSectors.Find(sec) == dedicatedMerchantSectors.Size()
				&& dedicatedSlotSectors.Find(sec) == dedicatedSlotSectors.Size()
			) {
				vector2 center = sec.centerspot;
				double secHeight = abs(sec.floorplane.ZAtPoint(center) - sec.ceilingplane.ZAtPoint(center));

				if (secHeight < 64) continue;

				secretSectors.Push(sec);
			}
		}

		int validSectorCount = secretSectors.Size();
		if (validSectorCount == 0 && dedicatedMerchantSectors.Size() == 0 && dedicatedSlotSectors.Size() == 0) return;

		// [Ace] Sort sectors by size in ascending order. Spawn merchants in smaller sectors first. Tiberium is the opposite - it prioritizes bigger sectors first.
		for (int i = 0; i < secretSectors.Size() - 1; ++i) {
			for (int j = i + 1; j < secretSectors.Size(); ++j) {
				if (AceCore.GetSectorSize(secretSectors[i]) > AceCore.GetSectorSize(secretSectors[j])) {
					let swap = secretSectors[i];
					secretSectors[i] = secretSectors[j];
					secretSectors[j] = swap;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// BITCHES DON'T KNOW 'BOUT MY TIBERIUM DEPOSITS.
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Spawn the crystals first, and only then bother with the merchants.
		if (MoneyMode == 0 || MoneyMode == 2) {
			for (int i = secretSectors.Size() - 1; i >= 0; --i) {
				if (hdm_debug >= 2 || random[merchrand](1, 100) <= AceCore.GetscaledChance(5, 40, acl_spawnscale_min, acl_spawnscale_max)) {
					SpawnedTiberium = true;
					SpawnCrystals(secretSectors[i]);
					secretSectors.Delete(i);
					if (hdm_debug < 2) break;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		//	MERCHANT SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Some boilerplate because I can't make local functions and the workaround is ironically worse.
		foreach (sec : dedicatedMerchantSectors) {
			vector3 spawnPos = (sec.centerspot, sec.floorplane.ZAtPoint(sec.centerspot));
			int spawnIndex = min(randompick(0, 0, 0, 1, 1, 2), AvailableMerchants.Size() - 1);
			Actor a = Actor.Spawn(AvailableMerchants[spawnIndex], spawnPos);
			a.angle = sec.GetUDMFInt('user_merchantangle');
			AvailableMerchants.Delete(spawnIndex);

			if (hdm_debug) Console.Printf("--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.", a.GetTag(), spawnPos.x, spawnPos.y);

			if (--MerchantsLeft == 0) break;
		}

		if (MerchantsLeft) {
			for (int i = 0; i < secretSectors.Size(); ++i) {
				vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 30) continue;
				int spawnIndex = min(randompick(0, 0, 0, 1, 1, 2), AvailableMerchants.Size() - 1);
				Actor a = Actor.Spawn(AvailableMerchants[spawnIndex], spawnPos);
				a.angle = secretSectors[i].GetUDMFInt('user_merchantangle');
				AvailableMerchants.Delete(spawnIndex);
				secretSectors.Delete(i--);

				if (hdm_debug) Console.Printf("--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.", a.GetTag(), spawnPos.x, spawnPos.y);

				if (--MerchantsLeft == 0) break;
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// SLOT MACHINE SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		bool spawnedMachine = false;
		for (int i = 0; i < dedicatedSlotSectors.Size(); ++i)
		{
			vector3 spawnPos = (dedicatedSlotSectors[i].centerspot, dedicatedSlotSectors[i].floorplane.ZAtPoint(dedicatedSlotSectors[i].centerspot));
			Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
			a.angle = dedicatedSlotSectors[i].GetUDMFInt('user_slotmachineangle');
			spawnedMachine = true;

			if (hdm_debug > 0)
			{
				Console.Printf("--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.", a.GetTag(), spawnPos.x, spawnPos.y);
			}
		}

		if (!spawnedMachine && hdm_enableslots)
		{
			for (int i = 0; i < secretSectors.Size(); ++i)
			{
				vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 20)
				{
					continue;
				}
				Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
				a.angle = secretSectors[i].GetUDMFInt('user_slotmachineangle');
				secretSectors.Delete(i--);

				if (hdm_debug > 0)
				{
					Console.Printf("--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.", a.GetTag(), spawnPos.x, spawnPos.y);
				}
				break;
			}
		}
	}

	override void WorldUnloaded(WorldEvent e)
	{
		let plr = players[Net_Arbitrator].mo;
		if (!plr)
		{
			return;
		}

		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (players[i].mo)
			{
				players[i].mo.A_TakeInventory("HDMerchantBody");
			}
		}
	}

	override void WorldTick()
	{
		if (GameInProgress)
		{
			PokerTick();
		}

		if (level.time == 35)
		{
			InitBounty();
			
			if (MoneyMode == 1 || (MoneyMode == 2 && !SpawnedTiberium))
			{
				int count = 1;
				for (int i = 0; i < 2; ++i)
				{
					if (random() <= AceCore.GetscaledChance(0, 64, 5, 15 + (5 * i)))
					{
						count++;
					}
					else
					{
						break;
					}
				}

				InitBountyTargets(count);
			}
		}
	}

	override void WorldThingDied(WorldEvent e)
	{
		if (e.thing
			&& !(
				e.thing is 'HDPlayerPawn'
				|| e.thing is 'HDPlayerCorpse'
				|| e.thing is 'HDBarrel'
			)
			&& hdm_nonbounty_dropratio > 0
		)
		{
			let mob = HDMobBase(e.thing);
			if (mob && !mob.bhasdropped)
			{
				DropCurrency(mob);
			}
		}
	}

	private void DropCurrency(HDMobBase mob)
	{
		// Get the raw amount of currency to drop
		let bounty = GetBounty(mob);
		let healthamt = mob.getspawnhealth() + (mob.maxshields / 2);
		let maxAmount = random(min(bounty, healthamt), max(bounty, healthamt)) * hdm_nonbounty_dropratio;
		let amount = random(0, maxAmount);

		if (Cvar.GetCVar('hdm_nonbounty_directdeposit').GetBool())
		{
			AceCore.GiveToPlayers('MercenaryBucks', amount); // Genericfiredemon: Code taken from line 263 of Bounty.zsc and modified for basic cash.
		}
		else
		{
			while (amount > 0)
			{
				if (amount >= 2000)
				{
					mob.DropNewItem('BigGem');
					amount -= 2000;
				}
				else if (amount >= 1000)
				{
					mob.DropNewItem('SmallGem');
					amount -= 1000;
				}
				else if (amount >= 750)
				{
					mob.DropNewItem('BigCoin');
					amount -= 750;
				}
				else if (amount >= 500)
				{
					mob.DropNewItem('MediumCoin');
					amount -= 500;
				}
				else if (amount >= 250)
				{
					mob.DropNewItem('SmallCoin');
					amount -= 250;
				}
				else if (amount >= 100)
				{
					mob.DropNewItem('MercenaryBucks100');
					amount -= 100;
				}
				else if (amount >= 25)
				{
					mob.DropNewItem('MercenaryBucks25');
					amount -= 25;
				}
				else
				{
					mob.DropNewItem('MercenaryBucks1');
					amount -= 1;
				}
			}
		}
	}
}
