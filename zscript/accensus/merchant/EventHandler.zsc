class MerchantHandler : EventHandler
{
	private int MoneyMode;
	private bool SpawnedTiberium;

	Array<name> NonBountyBlacklist;

	bool initialized;

	// Populates the Merchant Store Lists.
	void init() {

		if (initialized) return;

		BountyTargets.clear();
		NonBountyBlacklist.clear();
		SafeMapNames.clear();
		StoreCurrencies.clear();
		StoreItems.clear();

		let cmdReader = HDCoreInfoReader(StaticEventHandler.find('HDCoreInfoReader'));
		
		// Process all HDCore Commands,
		// as well as all loaded Child Classes for Bounties, Store Items/Currencies, etc.
		initBounties();
		initCurrencies();
		initStores();
		loadMerchantLists(cmdReader.commands);

		if (hdm_debug) {
			Console.printF("Merchant Bounty Targets:");
			forEach (target : BountyTargets) Console.printF(" * "..target.toString());

			Console.printF("Merchant Safe Maps:");
			forEach (mapName : SafeMapNames) Console.printF(" * "..mapName);

			Console.printF("Merchant Currencies:");
			forEach (currency : StoreCurrencies) Console.printF(" * "..currency.toString());

			Console.printF("Merchant Store Items:");
			forEach (item : StoreItems) Console.printF(" * "..item.toString());
		}

		initialized = true;
	}

	void loadMerchantLists(Array<HDCoreCommand> cmds) {
		forEach (cmd : cmds) {
			switch (cmd.command) {
				case 'newMerchantBountyTarget': {

					// Get Target's ClassName and check if it's valid
					let name = cmd.getNameParam("name");
					Class<Actor> cls = name;

					// If the target's class doesn't exist, quit.
					if (!cls) break;

					// get remaining params
					let effect = cmd.getNameParam("effect");
					let value = cmd.getIntParam("value");

					// Look for existing bounty target definitions
					BountyTarget existingTarget;
					forEach (t : BountyTargets) {
						if (t.targetCls == name) {
							existingTarget = t;
							break;
						}
					}

					// If an existing target for this class already exists, quit.
					if (existingTarget) break;

					// Create the new Bounty Target and add it to the registry.
					let newTarget = BountyTarget.create(name, value, effect);

					if (newTarget) BountyTargets.push(newTarget);

					break;
				}
				case 'removeMerchantBountyTarget': {

					let name = cmd.getNameParam("name");

					forEach (target : BountyTargets) {
						if (target.targetCls == name) {
							BountyTargets.delete(BountyTargets.find(target));
							break;
						}
					}

					break;
				}
				case 'clearMerchantBountyTargets': {
					BountyTargets.clear();
					break;
				}
				case 'addMerchantNonBountyBlacklist': {
					
					let name = cmd.getNameParam("name");

					if (name && NonBountyBlacklist.find(name) == NonBountyBlacklist.size()) NonBountyBlacklist.push(name);

					break;
				}
				case 'removeMerchantNonBountyBlacklist': {

					let name = cmd.getNameParam("name");

					if (NonBountyBlacklist.find(name) < NonBountyBlacklist.size()) NonBountyBlacklist.delete(NonBountyBlacklist.find(name));

					break;
				}
				case 'clearMerchantNonBountyBlacklist': {
					NonBountyBlacklist.clear();
					break;
				}
				case 'addMerchantSafeMap': {
					let name = cmd.getNameParam("name");

					if (name && SafeMapNames.find(name) == SafeMapNames.size()) SafeMapNames.push(name);
					break;
				}
				case 'removeMerchantSafeMap': {
					let name = cmd.getNameParam("name");

					if (SafeMapNames.find(name) < SafeMapNames.size()) SafeMapNames.delete(SafeMapNames.find(name));

					break;
				}
				case 'clearMerchantSafeMaps': {
					SafeMapNames.clear();
					break;
				}
				case 'newMerchantStoreCurrency': {
					
					// Get Currency name and check if it's valid
					let currency = cmd.getNameParam("name");
					Class<Inventory> currencyCls = currency;

					// If the currency's class doesn't exist, quit.
					if (!currencyCls) break;

					// get remaining params
					let icon = cmd.getStringParam("icon");
					let priceMult = cmd.getDoubleParam("priceMult", 1.0);

					// Look for existing currency definitions
					StoreCurrency existingCurrency;
					forEach (c : StoreCurrencies) {
						let currName = c.getCurrencyClass();

						if (currName != '' && currency != '' && currName == currency) {
							existingCurrency = c;
							break;
						}
					}

					// If an existing currency for this class already exists, quit.
					if (existingCurrency) break;

					// Create the new currency and add it to the registry.
					let newCurrency = StoreCurrency.create(currency, icon, priceMult);

					if (newCurrency) StoreCurrencies.push(newCurrency);

					break;
				}
				case 'removeMerchantStoreCurrency': {
					let currency = cmd.getNameParam("name");

					forEach (storeCurrency : StoreCurrencies) {
						if (storeCurrency.cls == currency) {
							StoreCurrencies.delete(StoreCurrencies.find(storeCurrency));
							break;
						}
					}

					break;
				}
				case 'clearMerchantStoreCurrencies': {
					StoreCurrencies.clear();
					break;
				}
				case 'newMerchantStoreItem': {
					
					// Get Item name and check if it's valid
					let item = cmd.getNameParam("item");
					Class<Actor> itemCls = item;
					
					// If the item's class doesn't exist, quit.
					if (!itemCls) break;
					
					// Get Item type and check if it's valid
					let type = cmd.getNameParam("type");
					int sType = -1;
					switch (type) {
						case 'ammo': {
							sType = SType_Ammo;
							break;
						}
						case 'item': {
							sType = SType_Item;
							break;
						}
						case 'weapon': {
							sType = SType_Weapon;
							break;
						}
						default: {
							Console.printF("\c[Red][MerchantHandler] Unknown Merchant Store Type: "..cmd.getNameParam("type"));
							break;
						}
					}
					
					// If the item type isn't valid, quit.
					if (sType < 0) break;

					// get remaining params
					let enabled = cmd.getBoolParam("enabled", true);
					let chance = cmd.getDoubleParam("chance", CVar.GetCVar(merchChances[sType]).GetFloat());
					let category = cmd.getStringParam("category", type);
					let icon = cmd.getStringParam("icon");
					let displayName = cmd.getStringParam("displayName", item);
					let flavorText = cmd.getStringParam("flavorText");
					let baseAmount = cmd.getIntParam("amount", 1);
					let basePrice = cmd.getIntParam("basePrice", 1);

					StoreItem existingItem;
					forEach (i : StoreItems) {
						let itemName = i.getItem();

						if (itemName != '' && item != '' && itemName == item) {
							existingItem = i;
							break;
						}
					}

					// If an existing store item for this class already exists, quit.
					if (existingItem) break;

					// Create the new store item and add it to the registry.
					let newItem = StoreItem.create(
						enabled,
						chance,
						sType,
						category,
						item,
						icon,
						displayName,
						flavorText,
						baseAmount,
						basePrice
					);

					if (newItem) StoreItems.push(newitem);

					break;
				}
				case 'removeMerchantStoreItem': {
					let item = cmd.getNameParam("name");

					forEach (storeItem : StoreItems) {
						if (storeItem.getItem() == item) {
							StoreItems.delete(StoreItems.find(storeItem));
							break;
						}
					}

					break;
				}
				case 'clearMerchantStoreItems': {
					StoreItems.clear();
					break;
				}
				default: {
					break;
				}
			}
		}
	}

	override void NetworkProcess(ConsoleEvent e) {

		let plr = players[e.Player].mo;
		name eventName = e.name;

		switch (eventName) {
			case 'HDM_AssemblePokerGame': {
				AssembleGame(plr);

				break;
			}
			case 'HDMPlaceBet': {
				PlaceBet(CardPlayers[PlayerIndex], e.Args[0]);

				break;
			}
			case 'HDM_Fold': {
				ActionTimer = 0;

				CardPlayers[PlayerIndex].HasFolded = true;
				RotatePlayer();

				break;
			}
			case 'HDM_Check': {
				ActionTimer = 0;

				CardPlayers[PlayerIndex].HasChecked = true;
				CardPlayers[PlayerIndex].Player.A_StartSound("Poker/Check", 10, CHANF_UI, attenuation: 1.5);
				RotatePlayer();

				break;
			}
			default: {
				Array<string> ParsedName;
				e.name.Split(ParsedName, ":");

				if (ParsedName[0] ~== "HDM_BuyStuff") {

					forEach (store : Stores) {

						StoreItem item;
						forEach (storeItem : store.StoreItems) {

							if (storeItem.GetItem() == ParsedName[1]) {
								item = storeItem;
								break;
							}
						}
		
						if (item && plr) {

							class<Actor> ItemClass = item.GetItem();
							int Amount = item.GetAmount();
		
							StoreCurrency Currency = StoreCurrencies[e.Args[0]];
							int Price = StoreItem.GetAdjustedPrice(item, Currency);
		
							// If the price is too high, play failure sound and quit.
							if (Price > plr.CountInv(Currency.GetCurrencyClass())) {
								plr.A_StartSound("Merchant/BuyFailure", 15, CHANF_LOCAL | CHANF_UI);
								return;
							}

							// If the thing bought is a pickup or pickup giver, give to the player & dump the overflow
							// otherwise just dump the thing on the ground.
							if (!(ItemClass is 'HDPickup') || ItemClass is 'HDPickupGiver') {
								Actor a; bool success;

								[success, a] = plr.A_SpawnItemEx(
									ItemClass,
									6, 0, plr.height - 8,
									frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0),
									0,
									SXF_NOCHECKPOSITION
								);

								if (success && a is 'Inventory') Inventory(a).Amount = amount;
							} else {
								class<Inventory> InvClass = (class<Inventory>)(ItemClass);
								int MaxGive = GetDefaultByType(InvClass).MaxAmount - plr.CountInv(InvClass);
								int MaxActualGive = min(Amount, MaxGive);

								// [Ace] Give what you can directly and drop the rest on the ground.
								plr.A_GiveInventory(InvClass, MaxActualGive);
								Amount -= MaxActualGive;

								if (Amount > 0) {
									Actor a; bool success;

									[success, a] = plr.A_SpawnItemEx(
										InvClass,
										6, 0, plr.height - 8,
										frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0),
										0,
										SXF_NOCHECKPOSITION
									);

									if (success) Inventory(a).Amount = Amount;
								}
							}

							// Take the currency from the player, play success sound, reduce stock
							plr.A_TakeInventory(Currency.GetCurrencyClass(), Price);
							plr.A_StartSound("Merchant/BuySuccess", 16, CHANF_LOCAL | CHANF_UI);
							item.StoreAmount--;

							// If there's none left, remove from the store.
							// TODO: Mark as disabled instead?
							if (item.StoreAmount <= 0) {
								store.StoreItems.Delete(store.StoreItems.Find(item));
								item.Destroy();
							}

							break;
						}
					}
				}

				break;
			}
		}
	}

	override void WorldLoaded(WorldEvent e) {

		if (e.IsReopen) return;

        // Populates the main arrays if they haven't been already.
        if (!initialized) init();

		MoneyMode = hdm_moneymode == 3 ? random(0, 1) : hdm_moneymode;
		
		// Initialize the stores for this map
		for (int i = 0; i < Stores.Size(); ++i) InitStore(i);
		
		if (hdm_debug) {
			Console.printF("Merchant Stores:");
			forEach (store : Stores) {
				forEach (category : store.Categories) {
					Console.printF(" * "..category.." Items:");
					forEach (item : store.StoreItems) {
						if (item.GetCategory() == category) {
							Console.printF("   * "..item.toString());
						}
					}
				}
			}
		}

		Array<class<HDMerchant> > AvailableMerchants;
		AvailableMerchants.Push('AmmoMerchant');
		AvailableMerchants.Push('ItemMerchant');
		AvailableMerchants.Push('WeaponMerchant');

		int mCount = AvailableMerchants.Size();
		int MerchantsLeft = min(mCount, level.MapName ~== "LOTSAGUN" ? mCount : CVar.GetCVar('hdm_maxmerchants').GetInt());

		Array<Sector> dedicatedMerchantSectors;
		Array<Sector> dedicatedSlotSectors;
		Array<Sector> secretSectors;

		foreach (sec : level.sectors) {
			if (sec.GetUDMFInt('user_merchantsector') == 1) {
				dedicatedMerchantSectors.Push(sec);
				continue;
			}

			if (sec.GetUDMFInt('user_slotmachinesector') == 1) {
				dedicatedSlotSectors.Push(sec);
				continue;
			}

			// [Ace] Secret sectors that are already dedicated don't count.
			
			// NOTE I: Don't spawn stuff in low sectors to prevent softlocking. You can climb crystals, but not if you slam your head into the ceiling doing so.
			if (
				sec.IsSecret()
				&& dedicatedMerchantSectors.Find(sec) == dedicatedMerchantSectors.Size()
				&& dedicatedSlotSectors.Find(sec) == dedicatedSlotSectors.Size()
			) {
				Vector2 center = sec.centerspot;
				double secHeight = abs(sec.floorplane.ZAtPoint(center) - sec.ceilingplane.ZAtPoint(center));

				if (secHeight < 64) continue;

				secretSectors.Push(sec);
			}
		}

		int validSectorCount = secretSectors.Size();
		if (validSectorCount == 0 && dedicatedMerchantSectors.Size() == 0 && dedicatedSlotSectors.Size() == 0) return;

		// [Ace] Sort sectors by size in ascending order. Spawn merchants in smaller sectors first. Tiberium is the opposite - it prioritizes bigger sectors first.
		for (int i = 0; i < secretSectors.Size() - 1; ++i) {
			for (int j = i + 1; j < secretSectors.Size(); ++j) {
				if (AceCore.GetSectorSize(secretSectors[i]) > AceCore.GetSectorSize(secretSectors[j])) {
					let swap = secretSectors[i];
					secretSectors[i] = secretSectors[j];
					secretSectors[j] = swap;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// BITCHES DON'T KNOW 'BOUT MY TIBERIUM DEPOSITS.
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Spawn the crystals first, and only then bother with the merchants.
		if (MoneyMode == 0 || MoneyMode == 2) {

			for (int i = secretSectors.Size() - 1; i >= 0; --i) {
				if (hdm_debug >= 2 || random[merchrand](1, 100) <= AceCore.GetscaledChance(5, 40, acl_spawnscale_min, acl_spawnscale_max)) {
					SpawnedTiberium = true;

					SpawnCrystals(secretSectors[i]);
					secretSectors.Delete(i);

					if (hdm_debug < 2) break;
				}
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		//	MERCHANT SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		// [Ace] Some boilerplate because I can't make local functions and the workaround is ironically worse.
		foreach (sec : dedicatedMerchantSectors) {
			Vector3 spawnPos = (sec.centerspot, sec.floorplane.ZAtPoint(sec.centerspot));
			int spawnIndex = min(randompick(0, 0, 0, 1, 1, 2), AvailableMerchants.Size() - 1);
			Actor a = Actor.Spawn(AvailableMerchants[spawnIndex], spawnPos);
			a.angle = sec.GetUDMFInt('user_merchantangle');
			AvailableMerchants.Delete(spawnIndex);

			if (hdm_debug) Console.Printf(
				"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
				a.GetTag(), spawnPos.x, spawnPos.y
			);

			if (--MerchantsLeft == 0) break;
		}

		if (MerchantsLeft) {
			for (int i = 0; i < secretSectors.Size(); ++i) {
				Vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 30) continue;
				int spawnIndex = min(randompick(0, 0, 0, 1, 1, 2), AvailableMerchants.Size() - 1);
				
				Actor a = Actor.Spawn(AvailableMerchants[spawnIndex], spawnPos);
				a.angle = secretSectors[i].GetUDMFInt('user_merchantangle');
				AvailableMerchants.Delete(spawnIndex);
				secretSectors.Delete(i--);

				if (hdm_debug) Console.Printf(
					"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
					a.GetTag(), spawnPos.x, spawnPos.y
				);

				if (--MerchantsLeft == 0) break;
			}
		}

		// ------------------------------------------------------------------------------------------------------------------------
		//
		// SLOT MACHINE SPAWNING
		// 
		// ------------------------------------------------------------------------------------------------------------------------

		bool spawnedMachine = false;
		for (int i = 0; i < dedicatedSlotSectors.Size(); i++) {

			Vector3 spawnPos = (dedicatedSlotSectors[i].centerspot, dedicatedSlotSectors[i].floorplane.ZAtPoint(dedicatedSlotSectors[i].centerspot));

			Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
			a.angle = dedicatedSlotSectors[i].GetUDMFInt('user_slotmachineangle');
			spawnedMachine = true;

			if (hdm_debug ) Console.Printf(
				"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
				a.GetTag(), spawnPos.x, spawnPos.y
			);
		}

		if (!spawnedMachine && hdm_enableslots) {

			for (int i = 0; i < secretSectors.Size(); i++) {

				Vector3 spawnPos = (secretSectors[i].centerspot, secretSectors[i].floorplane.ZAtPoint(secretSectors[i].centerspot));
				if (!level.IsPointInLevel(spawnPos) || random[merchrand](1, 100) <= 20) continue;

				Actor a = Actor.Spawn('MerchantSlotMachine', spawnPos);
				a.angle = secretSectors[i].GetUDMFInt('user_slotmachineangle');
				secretSectors.Delete(i--);

				if (hdm_debug) Console.Printf(
					"--------------------\nSpawned %s. Sector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
					a.GetTag(), spawnPos.x, spawnPos.y
				);

				break;
			}
		}
	}

	override void WorldUnloaded(WorldEvent e) {

		let plr = players[Net_Arbitrator].mo;
		if (!plr) return;

		forEach (p : PLAYERS) if (p.mo) p.mo.A_TakeInventory("HDMerchantBody");
	}

	override void WorldTick() {

		if (GameInProgress) PokerTick();

		// Initialize Bounty Target(s) Selection
		if (level.time == 35 && (MoneyMode == 1 || (MoneyMode == 2 && !SpawnedTiberium))) {
			int count = 1;
			for (int i = 0; i < 2; ++i) {

				if (random() <= AceCore.GetscaledChance(0, 64, 5, 15 + (5 * i))) {
					count++;
				} else {
					break;
				}
			}

			InitBountyTargets(count);
		}
	}

	override void WorldThingDied(WorldEvent e) {

		// If thing isn't some sort of HDMobBase, quit.
		// TODO: Expand to whitelist
		if (!(e.thing is 'HDMobBase')) return;

		// If thing is blacklisted, quit.
		forEach (bl : NonBountyBlacklist) if (e.thing is bl) return;

		// If the Non-Bounty Drop Ratio is a positive value,
		// and the thing hasn't died/dropped yet, drop currency.
		let mob = HDMobBase(e.thing);
		if (hdm_nonbounty_dropratio > 0 && !mob.bHASDROPPED) DropCurrency(mob);
	}

	private void DropCurrency(HDMobBase mob) {

		// Get the raw amount of currency to drop
		let bounty = GetBounty(mob);
		let healthamt = mob.getspawnhealth() + (mob.maxshields / 2);
		let maxAmount = random(min(bounty, healthamt), max(bounty, healthamt)) * hdm_nonbounty_dropratio;
		let amount = random(0, maxAmount);

		if (hdm_nonbounty_directdeposit) {

			// Genericfiredemon: Code taken from line 263 of Bounty.zsc and modified for basic cash.
			AceCore.GiveToPlayers('MercenaryBucks', amount);
		} else {

			while (amount > 0) {

				if (amount >= 2000) {
					mob.DropNewItem('BigGem');
					amount -= 2000;
				} else if (amount >= 1000) {
					mob.DropNewItem('SmallGem');
					amount -= 1000;
				} else if (amount >= 750) {
					mob.DropNewItem('BigCoin');
					amount -= 750;
				} else if (amount >= 500) {
					mob.DropNewItem('MediumCoin');
					amount -= 500;
				} else if (amount >= 250) {
					mob.DropNewItem('SmallCoin');
					amount -= 250;
				} else if (amount >= 100) {
					mob.DropNewItem('MercenaryBucks100');
					amount -= 100;
				} else if (amount >= 25) {
					mob.DropNewItem('MercenaryBucks25');
					amount -= 25;
				} else {
					mob.DropNewItem('MercenaryBucks1');
					amount -= 1;
				}
			}
		}
	}
}
