extend class MerchantHandler
{
	Array<BountyTarget> BountyTargets;

	private void InitBounties() {
		forEach (cls : AllClasses) {
			if (cls is 'BountyThinker' && cls != 'BountyThinker') {
				let thinker = BountyThinker(new(cls));

				let targetData = BountyTarget.Create(
					thinker.GetTargetName(),
					thinker.GetBounty(),
					thinker.GetEffectName()
				);

				if (targetData) BountyTargets.push(targetData);
			}
		}
	}

	private void InitBountyTargets(int count) {

		Array<Actor> chosenActors;
		chosenActors.clear();

		ThinkerIterator it = ThinkerIterator.Create('Actor', Thinker.STAT_DEFAULT);
		Actor a = null;
		while ((a = Actor(it.Next()))) {

			// Only consider non-friendly, alive, shootable monster actors as bounty targets
			if (!a.bISMONSTER || !a.bSHOOTABLE || a.bFRIENDLY || a.health <= 0) continue;
		
			forEach (target : BountyTargets) {

				// Find the appropriate BountyTarget entry,
				// and if the current actor hasn't been chosen and is an instance of the relevant actor class,
				// add it to the list of chosen actors.
				if (chosenActors.find(a) == chosenActors.size() && a is target.targetCls) chosenActors.Push(a);
			}
		}

		while (chosenActors.Size() > 0 && count > 0) {

			// Pick a random actor out of those that were chosen,
			// and if that chosen actor hasn't had a BountyTarget entry assigned,
			// create a BountyThinker for that actor and remove it from further selection
			int index = random(0, chosenActors.Size() - 1);
			Actor randAct = chosenActors[index];
			forEach (target : BountyTargets) {

				if (chosenActors.find(randAct) < chosenActors.size() && randAct is target.targetCls) {

					if (HDCore.ShouldLog('Merchant', LOGGING_DEBUG)) HDCore.Log(
						'Merchant', LOGGING_DEBUG, String.format(
							"Selected %s for bounty target, located @\c[DarkGray]%i\c-, \c[DarkGray]%i\c-.",
							randAct.GetTag(), randAct.pos.x, randAct.pos.y
						)
					);

					BountyThinker.Create(target, randAct);
					chosenActors.Delete(index);
					count--;
				}
			}
		}
	}

	int GetBounty(Actor actor) {
		
		// Find the BountyTarget that is associated with the given actor,
		// and return its configured bounty value.
		forEach (target : BountyTargets) {
			if (
				actor
				&& target
				&& target.targetCls != ''
				&& HDCore.IsChildClass(actor.GetClass(), target.targetCls)
			) {
				return target.value;
			}
		}

		return -1;
	}
}

// ----------------------------------------------------------------------
//
// EFFECTS - Monster-agnostic
// 
// ----------------------------------------------------------------------

class BountyEffect abstract play
{
	abstract void Init();
	virtual void Tick() {}

	void UpdateDynamicLight()
	{
		if (DynLight)
		{
			DynLight.SetOrigin(Target.pos + (0, 0, Target.height / 2), true);
		}
	}

	void CreateDynamicLight(class<PointLight> cls, int r, int g, int b, int size1, int size2)
	{
		DynLight = PointLight(Actor.Spawn("PointLight", Target.pos + (0, 0, Target.height / 2)));
		DynLight.Args[0] = r;
		DynLight.Args[1] = g;
		DynLight.Args[2] = b;
		DynLight.Args[3] = size1;
		DynLight.Args[4] = size2;
		DynLight.target = Target;
		DynLight.bATTENUATE = true;
	}

	override void OnDestroy()
	{
		if (DynLight)
		{
			DynLight.Destroy();
		}
	}

	private PointLight DynLight;
	Actor Target;
}

// ----------------------------------------------------------------------
//
// ----------------------------------------------------------------------

class BountyEffectStandard : BountyEffect
{
	override void Init()
	{
		Necromancer necro = Necromancer(Target);
		let sld = HDMagicShield(Target.FindInventory('HDMagicShield'));
		if (sld)
		{
			sld.MaxAmount = sld.Amount = max(2000, sld.MaxAmount << 1);
		}
		else
		{
			sld = HDMagicShield(Target.GiveInventoryType('HDMagicShield'));
			sld.MaxAmount = sld.Amount = necro ? 500 : 2000;
			sld.bSTANDSTILL = true;
			sld.bQUICKTORETALIATE = necro != null;
			sld.bSOLID = necro != null;
			if (necro)
			{
				sld.Speed = 5;
			}
		}
		/*
		if (!necro)
		{
			// [Ace] Changing StartHealth will change the return of subsequent SpawnHealth calls.
			Target.StartHealth = Target.Health = Target.SpawnHealth() << 1;
		}
		else
		{
			necro.hitsleft += 2;
		}
		*/
		Target.bMISSILEMORE = true;
		Target.bMISSILEEVENMORE = true;
		

		CreateDynamicLight('PointLight', 0xFF, 0xEE, 0x11, 48, 52);
	}

	override void Tick()
	{
		BountyBodyTrail trail = BountyBodyTrail(Target.Spawn('BountyBodyTrail', Target.Vec3Angle(-1, Target.angle)));
		trail.angle = Target.angle;
		trail.sprite = Target.sprite;
		trail.frame = Target.frame;
		trail.scale = Target.scale;
		UpdateDynamicLight();

		let mob = HDMobBase(Target);
		if (mob)
		{
			mob.bloodloss = max(0, mob.bloodloss - 4);
			mob.stunned = max(0, mob.stunned - 10);
		}
	}
}

class BountyBodyTrail : Actor
{
	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+BRIGHT
		Renderstyle "AddShaded";
		StencilColor "FFEE11";
	}

	States
	{
		Spawn:
			#### # 1
			{
				scale += (0.02, 0.02);
				A_FadeOut(0.1);
			}
			Loop;
	}
}

// ----------------------------------------------------------------------
//
// BOUNTIES - Monster-specific
// 
// ----------------------------------------------------------------------

class BountyTarget {
	name targetCls;
	int value;

	name effectCls;

	static BountyTarget Create(name targetCls, int value, name effectCls = '') {
		let bounty = BountyTarget(new('BountyTarget'));

		if (bounty) {
			bounty.targetCls = targetCls;
			bounty.value = value;

			bounty.effectCls = effectCls;
		}

		return bounty;
	}

	string toString() {
		return String.format(
			"{ targetCls=%s, effectCls=%s, value=%i }",
			   targetCls,    effectCls,    value
		);
	}
}

class BountyThinker : Thinker {

	private BountyTarget TargetData;
	private Actor Target;
	private BountyEffect Effect;
	
	static BountyThinker Create(BountyTarget data, Actor other) {

		let thk = BountyThinker(new("BountyThinker"));

		if (thk) {

			thk.TargetData = data;
			thk.Target = other;
	
			if (data.effectCls && (Class<BountyEffect>)(data.effectCls)) {
				thk.Effect = BountyEffect(new(data.effectCls));
			} else {

				// TODO: Refactor into Command Registry?
				Array< class<BountyEffect> > effects;
				effects.clear();

				forEach (cls : AllClasses) if (HDCore.IsChildClass(cls, 'BountyEffect')) effects.Push((Class<BountyEffect>)(cls));

				thk.Effect = BountyEffect(new(effects[random(0, effects.Size() - 1)]));
			}

			thk.Effect.Target = other;
			thk.Effect.Init();
		}

		return thk;
	}

	virtual name GetTargetName() {
		
		if (TargetData) return TargetData.targetCls;
		
		string clsName = GetClassName();
		if (clsName.left(14) ~== "BountyThinker_") return clsName.Mid(14);

		return clsName;
	}

	virtual name GetEffectName() {
		return Effect.getClassName();
	}

	virtual int GetBounty() {
		return TargetData ? TargetData.value : 0;
	}

	override void Tick() {

		// If the tracked target or the defined effect don't exist, quit.
		if (!Target || !Effect) {
			Destroy();
			return;
		}

		// If the tracked target is dead, trigger bounty & clean-up.
		if (Target.Health <= 0) {
			Target.A_StartSound("Bounty/HelloILikeMoney", 10, CHANF_OVERLAP, attenuation: 0.5);

			int amt = AceCore.GiveToPlayers('MercenaryBucks', GetBounty());

			// TODO: Define random deposit string format registry?
			string amtMsg = "\c[Green]$"..amt.."\c- have been deposited into your account.";
			if (!random(0, 12)) {
				amtMsg = "\c[Gold]"..amt.."\c- golds have been deposited into your Swiss bank account.";
			}

			Target.A_Log("\c[Red]!!! BOUNTY TARGET EXECUTED !!!\c-\n"..amtMsg);

			Destroy();
			return;
		}

		// Otherwise, just tick the Effect.
		Effect.Tick();
	}

	override void OnDestroy() {
		if (Effect) Effect.Destroy();

		TargetData.Destroy();
	}
}
